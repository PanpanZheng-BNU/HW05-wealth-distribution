using StatsBase, LinearAlgebra, Dates, Random
using CSV, DataFrames
using Distributions

## N is the total number of agents, length is the number of paris of an update
function randge(N::Int64, length::Int64)::Matrix{Int64}
    result::Matrix{Int64} = rand([1:N...], length, 2)
    norepeats(result) && return result
    randge(N, length)
end

## to improve the performance, we generate the whole selected index at each update at first.
function generate_si_all(N::Int64; length::Int64, lnn::Int64)::Array{Matrix{Int64}}
    si_all = Array{Matrix{Int64}}(undef, lnn)

    Threads.@threads for i = 1:lnn
        si_all[i] = randge(N, length)
    end
    return si_all
end


## The update function
function update!(m::Vector{Float64}; lambda::Vector{Float64}, si::Matrix{Int64})
    epsilon::Vector{Float64} = rand(size(si)[1])
    EPS::Matrix{Float64} = hcat(1 .- epsilon, epsilon)
    Li::Vector{Float64} = -(1 .- lambda[si[:, 1]])
    Lj::Vector{Float64} = 1 .- lambda[si[:, 2]]
    Deltam::Vector{Float64} = diag(EPS .* hcat(Li, Lj) * hcat(m[si[:, 1]], m[si[:, 2]])')
    m[si[:, 1]] .+= Deltam
    m[si[:, 2]] .-= Deltam
end

# Defint the λ generator, which is a vector of length N, and generate the λ according to the type of the second input;
## When the second input is ::Float64, it is the α in the paper, and the λ is generated by the power law;
function λ_generator(N::Int64, α::Float64)::Vector{Float64}
    return λ::Vector{Float64} = rand(N) .^ (1 / (1 + α))
end

## When the second input is ::Vector{Float64}, it is the interval of the uniform distribution, and the λ is generated by the uniform distribution;
function λ_generator(N::Int64, interval::Vector{Float64})::Vector{Float64}
    return λ::Vector{Float64} = rand(Uniform(interval...), N)
end
